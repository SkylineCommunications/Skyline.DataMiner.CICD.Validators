// <auto-generated>This is auto-generated code by Validator Management Tool. Do not modify.</auto-generated>
namespace Skyline.DataMiner.CICD.Validators.Protocol.Tests.Protocol.Responses.Response.Content.Param.CheckParamTag
{
    using System;
    using System.Collections.Generic;

    using Skyline.DataMiner.CICD.Models.Protocol.Read;
    using Skyline.DataMiner.CICD.Validators.Common.Interfaces;
    using Skyline.DataMiner.CICD.Validators.Common.Model;
    using Skyline.DataMiner.CICD.Validators.Protocol.Common;
    using Skyline.DataMiner.CICD.Validators.Protocol.Interfaces;

    internal static class Error
    {
        public static IValidationResult NonExistingId(IValidate test, IReadable referenceNode, IReadable positionNode, string referencedPid, string responseId)
        {
            return new ValidationResult
            {
                Test = test,
                CheckId = CheckId.CheckParamTag,
                ErrorId = ErrorIds.NonExistingId,
                FullId = "11.3.1",
                Category = Category.Response,
                Severity = Severity.Major,
                Certainty = Certainty.Certain,
                Source = Source.Validator,
                FixImpact = FixImpact.NonBreaking,
                GroupDescription = "",
                Description = String.Format("Tag '{0}' references a non-existing '{1}' with {2} '{3}'. {4} {5} '{6}'.", "Content/Param", "Param", "ID", referencedPid, "Response", "ID", responseId),
                HowToFix = "",
                ExampleCode = "",
                Details = "Response/Content tag should contain a list of 'Param' tags. The 'Param' tags should refer to the id of an existing Param.",
                HasCodeFix = false,

                PositionNode = positionNode,
                ReferenceNode = referenceNode,
            };
        }

        public static IValidationResult EmptyParamTag(IValidate test, IReadable referenceNode, IReadable positionNode, string responseId)
        {
            return new ValidationResult
            {
                Test = test,
                CheckId = CheckId.CheckParamTag,
                ErrorId = ErrorIds.EmptyParamTag,
                FullId = "11.3.2",
                Category = Category.Response,
                Severity = Severity.Major,
                Certainty = Certainty.Certain,
                Source = Source.Validator,
                FixImpact = FixImpact.NonBreaking,
                GroupDescription = "",
                Description = String.Format("Empty tag '{0}' in {1} '{2}'.", "Content/Param", "Response", responseId),
                HowToFix = "",
                ExampleCode = "",
                Details = "Response/Content tag should contain a list of 'Param' tags. The 'Param' tags should refer to the id of an existing Param.",
                HasCodeFix = false,

                PositionNode = positionNode,
                ReferenceNode = referenceNode,
            };
        }

        public static IValidationResult InvalidParamTag(IValidate test, IReadable referenceNode, IReadable positionNode, string value, string responseId)
        {
            return new ValidationResult
            {
                Test = test,
                CheckId = CheckId.CheckParamTag,
                ErrorId = ErrorIds.InvalidParamTag,
                FullId = "11.3.3",
                Category = Category.Response,
                Severity = Severity.Major,
                Certainty = Certainty.Certain,
                Source = Source.Validator,
                FixImpact = FixImpact.NonBreaking,
                GroupDescription = "",
                Description = String.Format("Invalid value '{0}' in tag '{1}'. {2} {4} '{3}'.", value, "Content/Param", "Response", responseId, "ID"),
                HowToFix = "",
                ExampleCode = "",
                Details = "Response/Content tag should contain a list of 'Param' tags. The 'Param' tags should refer to the id of an existing Param.",
                HasCodeFix = false,

                PositionNode = positionNode,
                ReferenceNode = referenceNode,
            };
        }

        public static IValidationResult UndesiredSavedReadParam(IValidate test, IReadable referenceNode, IReadable positionNode, string paramId, string responseId)
        {
            return new ValidationResult
            {
                Test = test,
                CheckId = CheckId.CheckParamTag,
                ErrorId = ErrorIds.UndesiredSavedReadParam,
                FullId = "11.3.4",
                Category = Category.Response,
                Severity = Severity.Minor,
                Certainty = Certainty.Certain,
                Source = Source.Validator,
                FixImpact = FixImpact.NonBreaking,
                GroupDescription = "",
                Description = String.Format("Unrecommended use of saved read parameter '{0}' within response '{1}'.", paramId, responseId),
                HowToFix = "Depending on the use-case, you should either remove the save option or include another parameter within your response." + Environment.NewLine + "- Is your parameter corresponding to a user configuration on the DataMiner element side -> don't use it in your response." + Environment.NewLine + "- Is your parameter corresponding to data or configuration retrieved from your data-source -> no need to save it." + Environment.NewLine + "" + Environment.NewLine + "There might be some use-cases where you need to use a dataminer element configuration parameter as a filter/validation on whether a data-source response should be accepted or not. In such cases,  you will indeed want to save such configuration parameter but then, you should copy its value to a fixed (and non-saved) parameter and include it within your response so that the user configuration does not get overwritten by the data-source response.",
                ExampleCode = "",
                Details = "Having a parameter being both saved and polled from the data-source seems inconsistent. Indeed:" + Environment.NewLine + "- A saved read parameter is typically used for configurations on the DataMiner element side so that user configuration can persist across restarts." + Environment.NewLine + "- A polled parameter will typically never need to be saved as we rely on the fact that the newer value will be polled again shortly after an element restart, no matter if such a parameter is a data parameter or a configuration parameter on the data-source side.",
                HasCodeFix = false,

                PositionNode = positionNode,
                ReferenceNode = referenceNode,
            };
        }
    }

    internal static class ErrorIds
    {
        public const uint NonExistingId = 1;
        public const uint EmptyParamTag = 2;
        public const uint InvalidParamTag = 3;
        public const uint UndesiredSavedReadParam = 4;
    }

    /// <summary>
    /// Contains the identifiers of the checks.
    /// </summary>
    public static class CheckId
    {
        /// <summary>
        /// The check identifier.
        /// </summary>
        public const uint CheckParamTag = 3;
    }
}